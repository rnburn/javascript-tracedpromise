{"version":3,"sources":["../src/tracedpromise.js"],"names":[],"mappings":";;;;;;;;AAAA;;IAAY,W;;;;;;AAEZ;;;;;AAKA,SAAS,WAAT,CAAqB,IAArB,EAA2B,CAA3B,EAA8B;AAC1B,QAAI,CAAC,IAAL,EAAW;AACP,eAAO,CAAP;AACH;AACD,WAAO,YAAmB;AACtB,aAAK,MAAL;AACA,eAAO,6BAAP;AACH,KAHD;AAIH;;AAED;;;;;AAKA,SAAS,UAAT,CAAoB,IAApB,EAA0B,CAA1B,EAA6B;AACzB,QAAI,CAAC,IAAL,EAAW;AACP,eAAO,CAAP;AACH;AACD,WAAO,YAAmB;AACtB,aAAK,MAAL,CAAY,OAAZ,EAAqB,IAArB;AACA,aAAK,MAAL;AACA,eAAO,6BAAP;AACH,KAJD;AAKH;;AAED;;;;;AAKA,SAAS,eAAT,CAAyB,OAAzB,EAAkC,IAAlC,EAAwC;AACpC,WAAO,QAAQ,IAAR,CAAa,UAAC,KAAD,EAAW;AAC3B,aAAK,MAAL;AACA,eAAO,KAAP;AACH,KAHM,EAGJ,UAAC,MAAD,EAAY;AACX,aAAK,MAAL,CAAY,OAAZ,EAAqB,IAArB;AACA,aAAK,MAAL;AACA,eAAO,QAAQ,MAAR,CAAe,MAAf,CAAP;AACH,KAPM,CAAP;AAQH;;AAED;;;;IAGqB,a;AACjB;;;;;;;;;;;;AAYA,2BAAY,OAAZ,EAAqB,IAArB,EAA2B,QAA3B,EAAqC;AAAA;;AACjC,YAAI,OAAO,OAAX;AACA,YAAI,mBAAmB,YAAY,IAAnC,EAAyC;AACrC,mBAAO,EAAE,SAAU,OAAZ,EAAP;AACH;AACD,YAAI,OAAO,YAAY,YAAZ,GACY,SADZ,CACsB,IADtB,EAC4B,IAD5B,CAAX;AAEA,YAAI,kBAAkB,SAAlB,eAAkB,CAAC,OAAD,EAAU,MAAV;AAAA,mBAAqB,SACvC,YAAY,IAAZ,EAAkB,OAAlB,CADuC,EAEvC,WAAW,IAAX,EAAiB,MAAjB,CAFuC,CAArB;AAAA,SAAtB;AAIA,aAAK,QAAL,GAAgB,IAAI,OAAJ,CAAY,eAAZ,CAAhB;AACA,aAAK,KAAL,GAAa,IAAb;AACH;;AAED;;;;;;;;6BAIK,W,EAAa,U,EAAY;AAC1B,mBAAO,KAAK,QAAL,CAAc,IAAd,CACH,YAAY,KAAK,KAAjB,EAAwB,WAAxB,CADG,EAEH,WAAW,KAAK,KAAhB,EAAuB,UAAvB,CAFG,CAAP;AAIH;;AAED;;;;;;;+BAIM,U,EAAY;AACd,mBAAO,KAAK,QAAL,CAAc,KAAd,CAAoB,WAAW,KAAK,KAAhB,EAAuB,UAAvB,CAApB,CAAP;AACH;;AAED;;;;;;;4BAIW,I,EAAM,G,EAAK;AAClB,mBAAO,gBAAgB,QAAQ,GAAR,CAAY,GAAZ,CAAhB,EAAkC,IAAlC,CAAP;AACH;;AAED;;;;;;;6BAIY,I,EAAM,G,EAAK;AACnB,mBAAO,gBAAgB,QAAQ,IAAR,CAAa,GAAb,CAAhB,EAAmC,IAAnC,CAAP;AACH;;AAED;;;;;;iCAGuB;AACnB,mBAAO,QAAQ,MAAR,0BAAP;AACH;;AAED;;;;;;kCAGwB;AACpB,mBAAO,QAAQ,QAAR,0BAAP;AACH;;;;;;kBA3EgB,a","file":"tracedpromise.js","sourcesContent":["import * as opentracing from 'opentracing';\n\n/*\n * wrapResolve is a helper that takes a standard ES6 Promise resolve callback\n * and returns a * wrapped function that first finishes the given `span` before\n * calling `f`. It is safe to call this function with a null or undefined span.\n */\nfunction wrapResolve(span, f) {\n    if (!span) {\n        return f;\n    }\n    return function (...args) {\n        span.finish();\n        return f(...args);\n    };\n}\n\n/*\n * wrapReject is a helper that takes a standard ES6 Promise resolve callback\n * and returns a * wrapped function that first finishes the given `span` before\n * calling `f`. It is safe to call this function with a null or undefined span.\n */\nfunction wrapReject(span, f) {\n    if (!span) {\n        return f;\n    }\n    return function (...args) {\n        span.setTag('error', true);\n        span.finish();\n        return f(...args);\n    };\n}\n\n/*\n * chainFinishSpan is a helper that finishes the given `span` when the `promise`\n * either rejects or resolved. It returns a valid Promise that so that chaining\n * can continue.\n */\nfunction chainFinishSpan(promise, span) {\n    return promise.then((value) => {\n        span.finish();\n        return value;\n    }, (reason) => {\n        span.setTag('error', true);\n        span.finish();\n        return Promise.reject(reason);\n    });\n}\n\n/**\n * TracedPromise adds OpenTracing instrumentation to a standard ES6 Promise.\n */\nexport default class TracedPromise {\n    /**\n     * Constructs anew TracedPromise\n     *\n     * @param {Object} options - the options to used to create the span for this\n     *        promise or the parent span.  Pass `null` for a promise that does\n     *        not have a parent.\n     * @param {string} name - name to use for the span created internally by\n     *        the TracedPromise.\n     * @param {Function} callback - callback to use to resolve the promise. The\n     *        signature and behavior should be that of a callback passed to a\n     *        standard ES6 Promise.\n     */\n    constructor(options, name, callback) {\n        let opts = options;\n        if (options instanceof opentracing.Span) {\n            opts = { childOf : options };\n        }\n        let span = opentracing.globalTracer()\n                              .startSpan(name, opts);\n        let wrappedCallback = (resolve, reject) => callback(\n            wrapResolve(span, resolve),\n            wrapReject(span, reject)\n        );\n        this._promise = new Promise(wrappedCallback);\n        this._span = span;\n    }\n\n    /**\n     * Has the same behavior as `Promise.then` with the addition that the\n     * TracedPromise's internal span will also be finished.\n     */\n    then(onFulfilled, onRejected) {\n        return this._promise.then(\n            wrapResolve(this._span, onFulfilled),\n            wrapReject(this._span, onRejected)\n        );\n    }\n\n    /**\n     * Has the same behavior as `Promise.catch` with the addition that the\n     * TracedPromise's internal span will also be finished.\n     */\n    catch(onRejected) {\n        return this._promise.catch(wrapReject(this._span, onRejected));\n    }\n\n    /**\n     * Has the same behavior as `Promise.all` with the addition that passed in\n     * `span` will be finish as soon as the returned Promise resolves or rejects.\n     */\n    static all(span, arr) {\n        return chainFinishSpan(Promise.all(arr), span);\n    }\n\n    /**\n     * Has the same behavior as `Promise.race` with the addition that passed in\n     * `span` will be finish as soon as the returned Promise resolves or rejects.\n     */\n    static race(span, arr) {\n        return chainFinishSpan(Promise.race(arr), span);\n    }\n\n    /**\n     * Equivalent to `Promise.reject`.\n     */\n    static reject(...args) {\n        return Promise.reject(...args);\n    }\n\n    /**\n     * Equivalent to `Promise.resolve`.\n     */\n    static resolve(...args) {\n        return Promise.resolved(...args);\n    }\n}\n"]}